Для отработки задания решила написать небольшой проект для трекинга задач, т.к. на рабочем проекте сейчас в основном задачи связаны с рефакторингом старого кода, а не написанием нового.

Верхнеуровнево примерно определила структуру: должен быть родительский класс Task, у него наследник SimpleTask, который представляет собой обычную задачу с 
дедлайном, и некий сервис, чтобы добавлять задачу, удалять, и просматривать задачи в порядке близости дедлайна. 
Решила для большей наглядности использовать в качестве хранилища задач in-memory контейнер, а не базу данных.
С этими вводными приступила к написанию тестов и кода.

Но уже вкоре столкнулась с проблемами. Например, тест для добавления задачи в хранилище:
```
@Test
void addSimpleTask() {
    Task task = new SimpleTask("Задача");
    service.addTask(task);
    assertNotNull(service.getTaskByName(task.getName()));
}
```
При написании даже такого простейшего теста уже возникло много вопросов. 
Как проверить, что задача действительно добавлена в хранилище? 

Дать доступ к внутренней структуре сервиса и напрямую проверять, что хранилище непустое? Вариант плохой, т.к. нарушается инкапсуляция.

Можно написать метод, который позволяет находить в хранилище нужную задачу. Но что передавать в качестве аргумента? Сам объект Task, или может искать по названию задачи? Решила искать по названию. 

Но тут уже получается, что в код добавляется метод getTaskByName, изначально вообще незапланированный, появившийся лишь ради тестов.

Далее делаю реализацию методов addTask, getTaskByName.
Но возникает вопрос, как будет работать getTaskByName, если у 2-х задач одинаковое название? Решаю такую ситуацию вообще запретить. 
Но тогда надо в методе addTask проверять наше хранилище, есть ли там уже задача с таким же названием. 

Исходя из этого кода, показалось логичным написать тест на попытку добавления в хранилище 2-х задач с одинаковыми именами, но разными описаниями, например. 
Но какой должен быть результат, ошибка, или может быть вторая задача должна переписать первую? Опять тест диктует, какую делать реализацию.
И так по кругу, все время получается, что сначала тест определяет код, потом код определяет тест, потом опять тест определяет код. Именно то, чего не должно быть согласно заданию. 

Зайдя в такой тупик, прочитала статьи о трех уровнях программной системы.

Для меня оказалось абсолютным неожиданным, что нельзя понять дизайн и предназначение программы просто читая код. Что одному коду может соответствовать множество дизайнов. 
Когда раньше сталкивалась с новым функционалом, сразу бралась читать код, пренебрегая документацией. Наверное, здесь играло роль то, что код читать интересней, чем документацию. 
Казалось, что так можно убить сразу двух зайцев -- и систему изучить, и уведеть как разные технологии применяются в коде. 
В итоге понимание системы сильно страдало, а я не могла понять, почему же картина не складывается. Теперь буду избегать этой ошибки.

Попыталась спроектировать трекер задач на уровне спецификации. 

Определила, какой функционал должен быть в системе:

- добавить новую задачу в хранилище
- удалить выбранную задачу 
- проверить наличие задачи в хранилище
- вернуть все задачи в отсортированном виде по увеличению даты дедлайна (для одинаковых дедлайнов - сортировка по названию задачи)
 
Здесь пришло в голову, что можно делать не просто какой-то сервис, а АТД TaskContainer. И для его методов задать пост- и пред- условия.

Вот как преобразовался тест и код на добавление задачи в хранилище:
```
@BeforeAll
    static void initTaskContainer() {
        taskContainer = new SimpleTaskContainer();
    }
    
 @Test
    void testAddTask() {
        SimpleTask task = new SimpleTask("Study TDD", "Write some tests", LocalDate.now());
        taskContainer.addTask(task);
        assertTrue(taskContainer.containsTask(task));
    }
```
Тест поменялся не очень сильно, но код значительно. Пришло на ум, что можно сразу хранить задачи в отсортированном виде, используя структуру данных дерево.
А чтобы обеспечить сортировку по имени для задач с одинаковым дедлайном, можно в качестве value хранить дерево задач, c ключом-названием задачи.
```
public class SimpleTaskContainer extends TaskContainer<SimpleTask> {

    private final TreeMap<LocalDate, TreeMap<String, SimpleTask>> map = new TreeMap<>();

    //постусловие: если в контейнере нет задачи с такими же name и deadline, добавлена новая задача. Иначе новая заменяет старую задачу.
    @Override
    public void addTask(SimpleTask task) {
        LocalDate deadline = task.deadline;
        String name = task.name;
        if (map.containsKey(deadline)) {
            map.get(deadline).put(name, task);
            return;
        }
        map.put(deadline, new TreeMap<>(Map.of(name, task)));
    }


    @Override
    public boolean containsTask(SimpleTask task) {
        LocalDate deadline = task.deadline;
        String name = task.name;
        return map.containsKey(deadline) && map.get(deadline).containsKey(name);
    }
}
```
В этом случае код уже не следует тестам, так же, как и тесты не следуют коду.
