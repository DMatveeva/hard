Во время выполнения задания был промежуток между проектами, поэтому решила использовать код учебного проекта "Автопарк".

1 итерация.
Использовала класс, служащий для генерации треков и координат.

Исходная версия:
https://github.com/DMatveeva/hard/blob/main/3_design/TrackGeneratorService.java

После переписывания:
https://github.com/DMatveeva/hard/blob/main/3_design/new/TrackGeneratorServiceNew.java

Словесное описание дизайна:
Сервис должен предоставить следующий функционал:

1. Генерация трека в реальном времени. Задаются параметры:
- авто
- начальная координата трека
- конечная координата трека
- максимальная скорость авто в км.ч

2. Генерация всего трека сразу. Задаются параметры:
- ид авто
- начальная координата трека
- конечная координата трека
- максимальная скорость авто в км.ч
- начальная дата-время поездки

3. Генерация заданного количества треков в определенном городе для всех авто заданного предприятия, единовременно. (В исходном варианте был метод для списка авто, но подумала, что будет проще сделать для всех авто предприятия, т.к. я так и использовала этот метод). Задаются параметры:
- название города, пока нужно поддержать 2 варианта(Лас-Вегас, Лос-Анжелес)
- ид предприятия, для которого генерировать треки
- количество треков для каждого авто
Для простоты задаем прямоугольную область, которая находится в данном городе.
Случайным образом берем 2 точки внутри этой области, используем их как стартовую и финишную координаты поездки.
Дата старта поездки выбирается случайным образом из фиксированного интервала.

Для получения списка координат обращаемся к стороннему API.
Передаем стартовую и финишную координаты, максимальную скорость, получаем список координат.
Записываем координаты из списка в БД с заданным интервалом (секунды).
Если выбрана генерация трека без задержки, то сразу записываем в БД.


Рефлексия:
1 день. Просто перечитывала код, пытаясь сформулировать словесный дизайн. Было сложно словами выразить то, что писала в коде, тем более что было сложно вспомнить и понять, что происходит в коде.
2 день. Сформулировала общие формулировки дизайна.
3 день. Находила расхождения в текущем коде и дизайне. Искала, за что зацепится, с чего начать переписывать код. Решила, что начну с того, что уберу циклы с длинной логикой, постараюсь превратить их в Streams, чтобы более декларативный стиль получился. А также постараюсь убрать цепочки if ... else
if ... else. Также смущало, что минимальная/максимальная широта и долгота для 2-х городов в коде прописаны просто как константы. Решила сделать отдельный класс enum City.
6 день. Переписывала код. Решила вынести обращение к API OpenRoute в отдельный класс RouteUtil. Подумала, что это позволит в будущем без больших проблем заменить его на другой API, если потребуется. Логика генерации не будет перемещена с логикой обращения к API и преобразования полученного ответа, как в исходном варианте.
 Старалась все циклы поменять на Stream, и не понравилось, что JSONArray (org.json) нельзя обработать в декларативном стиле. Можно только в цикле. Искала, как превратить его в Stream, но нашла решение лучше. Вместо org.json стала использовать Jackson, и нашла стандартный алгоритм декодирования
 ломаной geometry в 2 строчки, что помогло избавиться от класса GeometryDecoder.
 7 день. Продолжала переписывать код. Разделила сервис генерации на 2 класса, InstantTrackGeneratorService (генерация треков без задержки) и RealTimeTrackGeneratorService (для генерации в реальном времени), создала для них интерфейсы InstantTrackGenerator, RealTimeTrackGenerator. Вынесла общие  вспомогательные методы в классы VehicleCoordinateUtil, DateUtil.

 Итого 1-я итерация заняла 7 дней.


2 итерация.
Использовала класс, служащий для генерации авто со случайными параметрами.

Исходная версия:
https://github.com/DMatveeva/hard/blob/main/3_design/VehicleGeneratorService.java

После переписывания:
https://github.com/DMatveeva/hard/blob/main/3_design/new/VehicleGeneratorServiceNew.java

Сервис должен предоставить следующий функционал:
- Генерировать заданное количество автомобилей со случайными параметрами, для заданного списка предприятий. Сохранять полученные авто в БД.

При переписывании кода применяла те же приемы, что и для итерации 1, т.к. классы похожи.
Это заняло 1 вечер.
